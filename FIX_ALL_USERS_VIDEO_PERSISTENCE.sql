-- ============================================================
-- FIX VIDEO PERSISTENCE FOR ALL USERS
-- This ensures ALL users' videos persist after refresh and appear
-- in the public feed, just like kenxokent account videos
-- ============================================================
-- Run this in Supabase SQL Editor to fix the issue
-- ============================================================

-- STEP 1: Ensure posts table exists with correct structure
CREATE TABLE IF NOT EXISTS posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  video_path TEXT NOT NULL,
  description TEXT DEFAULT '',
  category TEXT DEFAULT 'comedy',
  visibility TEXT DEFAULT 'public' CHECK (visibility IN ('public', 'private', 'friends')),
  likes_count INTEGER DEFAULT 0,
  comments_count INTEGER DEFAULT 0,
  shares_count INTEGER DEFAULT 0,
  views_count INTEGER DEFAULT 0,
  poster_url TEXT,
  duration INTEGER DEFAULT 0,
  location TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- STEP 2: Add indexes for performance (critical for fast loading)
CREATE INDEX IF NOT EXISTS idx_posts_user_id ON posts(user_id);
CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_posts_visibility ON posts(visibility);
CREATE INDEX IF NOT EXISTS idx_posts_category ON posts(category);
CREATE INDEX IF NOT EXISTS idx_posts_public_created ON posts(visibility, created_at DESC) WHERE visibility = 'public';

-- STEP 3: Enable Row Level Security
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;

-- STEP 4: Drop ALL old policies (clean slate)
DO $$ 
DECLARE
    policy_rec RECORD;
BEGIN
    FOR policy_rec IN 
        SELECT policyname 
        FROM pg_policies 
        WHERE tablename = 'posts'
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON posts', policy_rec.policyname);
    END LOOP;
END $$;

-- STEP 5: Create NEW policies for TikTok-style public feed

-- ✅ CRITICAL: Everyone can VIEW all public posts (including anonymous users)
-- This is what makes videos appear in the feed for ALL users
CREATE POLICY "everyone_can_view_public_posts"
ON posts
FOR SELECT
TO public
USING (visibility = 'public');

-- ✅ Authenticated users can INSERT their own posts
CREATE POLICY "authenticated_users_can_create_posts"
ON posts
FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

-- ✅ Users can UPDATE their own posts
CREATE POLICY "users_can_update_own_posts"
ON posts
FOR UPDATE
TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- ✅ Users can DELETE their own posts
CREATE POLICY "users_can_delete_own_posts"
ON posts
FOR DELETE
TO authenticated
USING (auth.uid() = user_id);

-- STEP 6: Grant table permissions
GRANT SELECT ON posts TO anon;
GRANT SELECT ON posts TO authenticated;
GRANT INSERT, UPDATE, DELETE ON posts TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE posts_id_seq TO authenticated;

-- STEP 7: Ensure storage bucket exists and has correct policies
-- Note: Bucket must be created first in Supabase Dashboard > Storage

-- Drop old storage policies
DO $$ 
DECLARE
    policy_rec RECORD;
BEGIN
    FOR policy_rec IN 
        SELECT policyname 
        FROM pg_policies 
        WHERE tablename = 'objects' 
        AND schemaname = 'storage'
        AND (policyname LIKE '%video%' OR policyname LIKE '%upload%')
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON storage.objects', policy_rec.policyname);
    END LOOP;
END $$;

-- ✅ Everyone can VIEW video files (public read access)
CREATE POLICY "public_can_view_all_videos"
ON storage.objects
FOR SELECT
TO public
USING (bucket_id = 'videos');

-- ✅ Authenticated users can UPLOAD video files
CREATE POLICY "authenticated_can_upload_videos"
ON storage.objects
FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'videos' AND auth.role() = 'authenticated');

-- ✅ Users can UPDATE their own video files (for metadata)
CREATE POLICY "users_can_update_own_video_files"
ON storage.objects
FOR UPDATE
TO authenticated
USING (
  bucket_id = 'videos' AND
  (storage.foldername(name))[1] = auth.uid()::text
)
WITH CHECK (
  bucket_id = 'videos' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- ✅ Users can DELETE their own video files
CREATE POLICY "users_can_delete_own_video_files"
ON storage.objects
FOR DELETE
TO authenticated
USING (
  bucket_id = 'videos' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- STEP 8: Create profiles table if it doesn't exist
CREATE TABLE IF NOT EXISTS profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE,
  full_name TEXT NOT NULL,
  display_name TEXT,
  avatar_url TEXT,
  bio TEXT,
  followers_count INTEGER DEFAULT 0,
  following_count INTEGER DEFAULT 0,
  likes_count INTEGER DEFAULT 0,
  coins INTEGER DEFAULT 0,
  is_seller BOOLEAN DEFAULT false,
  email TEXT,
  profile_views_enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add profiles indexes
CREATE INDEX IF NOT EXISTS idx_profiles_username ON profiles(username);
CREATE INDEX IF NOT EXISTS idx_profiles_created_at ON profiles(created_at DESC);

-- Enable RLS on profiles
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Profiles policies
DROP POLICY IF EXISTS "public_can_view_profiles" ON profiles;
DROP POLICY IF EXISTS "users_can_update_own_profile" ON profiles;
DROP POLICY IF EXISTS "users_can_insert_own_profile" ON profiles;

CREATE POLICY "public_can_view_profiles"
ON profiles FOR SELECT
TO public
USING (true);

CREATE POLICY "users_can_update_own_profile"
ON profiles FOR UPDATE
TO authenticated
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

CREATE POLICY "users_can_insert_own_profile"
ON profiles FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = id);

GRANT SELECT ON profiles TO anon;
GRANT SELECT ON profiles TO authenticated;
GRANT INSERT, UPDATE ON profiles TO authenticated;

-- STEP 9: Create function to auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for posts
DROP TRIGGER IF EXISTS update_posts_updated_at ON posts;
CREATE TRIGGER update_posts_updated_at
  BEFORE UPDATE ON posts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create trigger for profiles
DROP TRIGGER IF EXISTS update_profiles_updated_at ON profiles;
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- STEP 10: Create view for posts with user info (for easier queries)
CREATE OR REPLACE VIEW posts_with_profiles AS
SELECT 
  p.*,
  pr.username,
  pr.full_name,
  pr.display_name,
  pr.avatar_url,
  pr.followers_count
FROM posts p
LEFT JOIN profiles pr ON p.user_id = pr.id
WHERE p.visibility = 'public'
ORDER BY p.created_at DESC;

-- Grant access to view
GRANT SELECT ON posts_with_profiles TO anon;
GRANT SELECT ON posts_with_profiles TO authenticated;

-- STEP 11: Migrate existing videos table data to posts table (if any)
-- This ensures any old videos are not lost
DO $$
DECLARE
  video_rec RECORD;
  new_post_id BIGINT;
BEGIN
  -- Check if videos table exists
  IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'videos') THEN
    -- Migrate each video to posts table
    FOR video_rec IN SELECT * FROM videos WHERE is_published = true
    LOOP
      -- Check if already migrated
      IF NOT EXISTS (SELECT 1 FROM posts WHERE video_path = video_rec.file_path) THEN
        INSERT INTO posts (
          user_id,
          video_path,
          description,
          category,
          visibility,
          likes_count,
          comments_count,
          shares_count,
          views_count,
          poster_url,
          duration,
          location,
          created_at,
          updated_at
        ) VALUES (
          video_rec.user_id,
          video_rec.file_path,
          video_rec.description,
          video_rec.category,
          'public', -- All published videos become public posts
          video_rec.likes_count,
          video_rec.comments_count,
          video_rec.shares_count,
          video_rec.views_count,
          video_rec.poster_url,
          video_rec.duration,
          video_rec.location_name,
          video_rec.created_at,
          video_rec.updated_at
        );
        
        RAISE NOTICE 'Migrated video % to posts table', video_rec.id;
      END IF;
    END LOOP;
    
    RAISE NOTICE 'Migration complete!';
  END IF;
END $$;

-- STEP 12: Verify setup
SELECT 
  'Posts Table' as check_type,
  COUNT(*) as count
FROM posts
UNION ALL
SELECT 
  'Profiles Table' as check_type,
  COUNT(*) as count
FROM profiles
UNION ALL
SELECT 
  'Posts Policies' as check_type,
  COUNT(*) as count
FROM pg_policies 
WHERE tablename = 'posts'
UNION ALL
SELECT 
  'Storage Policies' as check_type,
  COUNT(*) as count
FROM pg_policies 
WHERE tablename = 'objects' AND schemaname = 'storage' AND policyname LIKE '%video%';

-- STEP 13: Test query (should return all public posts)
-- Run this to verify posts are accessible:
-- SELECT id, user_id, description, video_path, created_at FROM posts WHERE visibility = 'public' ORDER BY created_at DESC LIMIT 10;

-- ============================================================
-- ✅ SETUP COMPLETE!
-- 
-- What this fixes:
-- 1. ALL users' videos now persist in database after page refresh
-- 2. ALL users (including anonymous) can see all uploaded videos
-- 3. Videos appear in public feed like TikTok for EVERYONE
-- 4. Proper permissions for upload, update, delete
-- 5. Optimized indexes for fast loading
-- 6. Migrated any old videos from videos table to posts table
--
-- The kenxokent account was working because it was already using
-- this posts table structure. Now ALL users will have the same
-- reliable experience!
--
-- Next steps:
-- 1. Verify your Supabase environment variables in Vercel:
--    - VITE_SUPABASE_URL
--    - VITE_SUPABASE_ANON_KEY
--    - SUPABASE_SERVICE_ROLE_KEY (for API endpoints)
--
-- 2. Test by uploading a video from any account and refreshing
--
-- 3. Check that videos appear for other users
-- ============================================================
